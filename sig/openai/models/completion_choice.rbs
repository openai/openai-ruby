module OpenAI
  module Models
    type completion_choice =
      {
        finish_reason: OpenAI::Models::CompletionChoice::finish_reason,
        index: Integer,
        logprobs: OpenAI::Models::CompletionChoice::Logprobs?,
        text: String
      }

    class CompletionChoice < OpenAI::BaseModel
      attr_accessor finish_reason: OpenAI::Models::CompletionChoice::finish_reason

      attr_accessor index: Integer

      attr_accessor logprobs: OpenAI::Models::CompletionChoice::Logprobs?

      attr_accessor text: String

      def initialize:
        (
          finish_reason: OpenAI::Models::CompletionChoice::finish_reason,
          index: Integer,
          logprobs: OpenAI::Models::CompletionChoice::Logprobs?,
          text: String
        ) -> void
        | (?OpenAI::Models::completion_choice | OpenAI::BaseModel data) -> void

      def to_hash: -> OpenAI::Models::completion_choice

      type finish_reason = :stop | :length | :content_filter

      class FinishReason < OpenAI::Enum
        STOP: :stop
        LENGTH: :length
        CONTENT_FILTER: :content_filter

        def self.values: -> ::Array[OpenAI::Models::CompletionChoice::finish_reason]
      end

      type logprobs =
        {
          text_offset: ::Array[Integer],
          token_logprobs: ::Array[Float],
          tokens: ::Array[String],
          top_logprobs: ::Array[::Hash[Symbol, Float]]
        }

      class Logprobs < OpenAI::BaseModel
        attr_reader text_offset: ::Array[Integer]?

        def text_offset=: (::Array[Integer]) -> ::Array[Integer]

        attr_reader token_logprobs: ::Array[Float]?

        def token_logprobs=: (::Array[Float]) -> ::Array[Float]

        attr_reader tokens: ::Array[String]?

        def tokens=: (::Array[String]) -> ::Array[String]

        attr_reader top_logprobs: ::Array[::Hash[Symbol, Float]]?

        def top_logprobs=: (
          ::Array[::Hash[Symbol, Float]]
        ) -> ::Array[::Hash[Symbol, Float]]

        def initialize:
          (
            ?text_offset: ::Array[Integer],
            ?token_logprobs: ::Array[Float],
            ?tokens: ::Array[String],
            ?top_logprobs: ::Array[::Hash[Symbol, Float]]
          ) -> void
          | (
            ?OpenAI::Models::CompletionChoice::logprobs | OpenAI::BaseModel data
          ) -> void

        def to_hash: -> OpenAI::Models::CompletionChoice::logprobs
      end
    end
  end
end
