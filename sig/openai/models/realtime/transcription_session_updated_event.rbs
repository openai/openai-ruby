module OpenAI
  module Models
    module Realtime
      type transcription_session_updated_event =
        {
          event_id: String,
          session: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session,
          type: :"transcription_session.updated"
        }

      class TranscriptionSessionUpdatedEvent < OpenAI::Internal::Type::BaseModel
        attr_accessor event_id: String

        attr_accessor session: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session

        attr_accessor type: :"transcription_session.updated"

        def initialize: (
          event_id: String,
          session: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session,
          ?type: :"transcription_session.updated"
        ) -> void

        def to_hash: -> {
          event_id: String,
          session: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session,
          type: :"transcription_session.updated"
        }

        type session =
          {
            client_secret: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::ClientSecret,
            input_audio_format: String,
            input_audio_transcription: OpenAI::Realtime::AudioTranscription,
            modalities: ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality],
            turn_detection: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection
          }

        class Session < OpenAI::Internal::Type::BaseModel
          attr_accessor client_secret: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::ClientSecret

          attr_reader input_audio_format: String?

          def input_audio_format=: (String) -> String

          attr_reader input_audio_transcription: OpenAI::Realtime::AudioTranscription?

          def input_audio_transcription=: (
            OpenAI::Realtime::AudioTranscription
          ) -> OpenAI::Realtime::AudioTranscription

          attr_reader modalities: ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality]?

          def modalities=: (
            ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality]
          ) -> ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality]

          attr_reader turn_detection: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection?

          def turn_detection=: (
            OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection
          ) -> OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection

          def initialize: (
            client_secret: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::ClientSecret,
            ?input_audio_format: String,
            ?input_audio_transcription: OpenAI::Realtime::AudioTranscription,
            ?modalities: ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality],
            ?turn_detection: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection
          ) -> void

          def to_hash: -> {
            client_secret: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::ClientSecret,
            input_audio_format: String,
            input_audio_transcription: OpenAI::Realtime::AudioTranscription,
            modalities: ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality],
            turn_detection: OpenAI::Realtime::TranscriptionSessionUpdatedEvent::Session::TurnDetection
          }

          type client_secret = { expires_at: Integer, value: String }

          class ClientSecret < OpenAI::Internal::Type::BaseModel
            attr_accessor expires_at: Integer

            attr_accessor value: String

            def initialize: (expires_at: Integer, value: String) -> void

            def to_hash: -> { expires_at: Integer, value: String }
          end

          type modality = :text | :audio

          module Modality
            extend OpenAI::Internal::Type::Enum

            TEXT: :text
            AUDIO: :audio

            def self?.values: -> ::Array[OpenAI::Models::Realtime::TranscriptionSessionUpdatedEvent::Session::modality]
          end

          type turn_detection =
            {
              prefix_padding_ms: Integer,
              silence_duration_ms: Integer,
              threshold: Float,
              type: String
            }

          class TurnDetection < OpenAI::Internal::Type::BaseModel
            attr_reader prefix_padding_ms: Integer?

            def prefix_padding_ms=: (Integer) -> Integer

            attr_reader silence_duration_ms: Integer?

            def silence_duration_ms=: (Integer) -> Integer

            attr_reader threshold: Float?

            def threshold=: (Float) -> Float

            attr_reader type: String?

            def type=: (String) -> String

            def initialize: (
              ?prefix_padding_ms: Integer,
              ?silence_duration_ms: Integer,
              ?threshold: Float,
              ?type: String
            ) -> void

            def to_hash: -> {
              prefix_padding_ms: Integer,
              silence_duration_ms: Integer,
              threshold: Float,
              type: String
            }
          end
        end
      end
    end
  end
end
