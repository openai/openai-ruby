module OpenAI
  module Models
    module Realtime
      type realtime_tools_config_union =
        OpenAI::Realtime::RealtimeToolsConfigUnion::Function
        | OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp

      module RealtimeToolsConfigUnion
        extend OpenAI::Internal::Type::Union

        type function =
          {
            description: String,
            name: String,
            parameters: top,
            type: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_
          }

        class Function < OpenAI::Internal::Type::BaseModel
          attr_reader description: String?

          def description=: (String) -> String

          attr_reader name: String?

          def name=: (String) -> String

          attr_reader parameters: top?

          def parameters=: (top) -> top

          attr_reader type: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_?

          def type=: (
            OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_
          ) -> OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_

          def initialize: (
            ?description: String,
            ?name: String,
            ?parameters: top,
            ?type: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_
          ) -> void

          def to_hash: -> {
            description: String,
            name: String,
            parameters: top,
            type: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_
          }

          type type_ = :function

          module Type
            extend OpenAI::Internal::Type::Enum

            FUNCTION: :function

            def self?.values: -> ::Array[OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Function::type_]
          end
        end

        type mcp =
          {
            server_label: String,
            type: :mcp,
            allowed_tools: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::allowed_tools?,
            authorization: String,
            connector_id: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id,
            headers: ::Hash[Symbol, String]?,
            require_approval: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::require_approval?,
            server_description: String,
            server_url: String
          }

        class Mcp < OpenAI::Internal::Type::BaseModel
          attr_accessor server_label: String

          attr_accessor type: :mcp

          attr_accessor allowed_tools: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::allowed_tools?

          attr_reader authorization: String?

          def authorization=: (String) -> String

          attr_reader connector_id: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id?

          def connector_id=: (
            OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id
          ) -> OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id

          attr_accessor headers: ::Hash[Symbol, String]?

          attr_accessor require_approval: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::require_approval?

          attr_reader server_description: String?

          def server_description=: (String) -> String

          attr_reader server_url: String?

          def server_url=: (String) -> String

          def initialize: (
            server_label: String,
            ?allowed_tools: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::allowed_tools?,
            ?authorization: String,
            ?connector_id: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id,
            ?headers: ::Hash[Symbol, String]?,
            ?require_approval: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::require_approval?,
            ?server_description: String,
            ?server_url: String,
            ?type: :mcp
          ) -> void

          def to_hash: -> {
            server_label: String,
            type: :mcp,
            allowed_tools: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::allowed_tools?,
            authorization: String,
            connector_id: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id,
            headers: ::Hash[Symbol, String]?,
            require_approval: OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::require_approval?,
            server_description: String,
            server_url: String
          }

          type allowed_tools =
            ::Array[String]
            | OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::AllowedTools::McpToolFilter

          module AllowedTools
            extend OpenAI::Internal::Type::Union

            type mcp_tool_filter =
              { read_only: bool, tool_names: ::Array[String] }

            class McpToolFilter < OpenAI::Internal::Type::BaseModel
              attr_reader read_only: bool?

              def read_only=: (bool) -> bool

              attr_reader tool_names: ::Array[String]?

              def tool_names=: (::Array[String]) -> ::Array[String]

              def initialize: (
                ?read_only: bool,
                ?tool_names: ::Array[String]
              ) -> void

              def to_hash: -> { read_only: bool, tool_names: ::Array[String] }
            end

            def self?.variants: -> ::Array[OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::allowed_tools]

            StringArray: OpenAI::Internal::Type::Converter
          end

          type connector_id =
            :connector_dropbox
            | :connector_gmail
            | :connector_googlecalendar
            | :connector_googledrive
            | :connector_microsoftteams
            | :connector_outlookcalendar
            | :connector_outlookemail
            | :connector_sharepoint

          module ConnectorID
            extend OpenAI::Internal::Type::Enum

            CONNECTOR_DROPBOX: :connector_dropbox
            CONNECTOR_GMAIL: :connector_gmail
            CONNECTOR_GOOGLECALENDAR: :connector_googlecalendar
            CONNECTOR_GOOGLEDRIVE: :connector_googledrive
            CONNECTOR_MICROSOFTTEAMS: :connector_microsoftteams
            CONNECTOR_OUTLOOKCALENDAR: :connector_outlookcalendar
            CONNECTOR_OUTLOOKEMAIL: :connector_outlookemail
            CONNECTOR_SHAREPOINT: :connector_sharepoint

            def self?.values: -> ::Array[OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::connector_id]
          end

          type require_approval =
            OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter
            | OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::mcp_tool_approval_setting

          module RequireApproval
            extend OpenAI::Internal::Type::Union

            type mcp_tool_approval_filter =
              {
                always: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always,
                never: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never
              }

            class McpToolApprovalFilter < OpenAI::Internal::Type::BaseModel
              attr_reader always: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always?

              def always=: (
                OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always
              ) -> OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always

              attr_reader never: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never?

              def never=: (
                OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never
              ) -> OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never

              def initialize: (
                ?always: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always,
                ?never: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never
              ) -> void

              def to_hash: -> {
                always: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Always,
                never: OpenAI::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::McpToolApprovalFilter::Never
              }

              type always = { read_only: bool, tool_names: ::Array[String] }

              class Always < OpenAI::Internal::Type::BaseModel
                attr_reader read_only: bool?

                def read_only=: (bool) -> bool

                attr_reader tool_names: ::Array[String]?

                def tool_names=: (::Array[String]) -> ::Array[String]

                def initialize: (
                  ?read_only: bool,
                  ?tool_names: ::Array[String]
                ) -> void

                def to_hash: -> { read_only: bool, tool_names: ::Array[String] }
              end

              type never = { read_only: bool, tool_names: ::Array[String] }

              class Never < OpenAI::Internal::Type::BaseModel
                attr_reader read_only: bool?

                def read_only=: (bool) -> bool

                attr_reader tool_names: ::Array[String]?

                def tool_names=: (::Array[String]) -> ::Array[String]

                def initialize: (
                  ?read_only: bool,
                  ?tool_names: ::Array[String]
                ) -> void

                def to_hash: -> { read_only: bool, tool_names: ::Array[String] }
              end
            end

            type mcp_tool_approval_setting = :always | :never

            module McpToolApprovalSetting
              extend OpenAI::Internal::Type::Enum

              ALWAYS: :always
              NEVER: :never

              def self?.values: -> ::Array[OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::RequireApproval::mcp_tool_approval_setting]
            end

            def self?.variants: -> ::Array[OpenAI::Models::Realtime::RealtimeToolsConfigUnion::Mcp::require_approval]
          end
        end

        def self?.variants: -> ::Array[OpenAI::Models::Realtime::realtime_tools_config_union]
      end
    end
  end
end
