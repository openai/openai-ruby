module OpenAI
  module Models
    module Realtime
      type realtime_transcription_session_audio_input_turn_detection =
        OpenAI::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::ServerVad
        | OpenAI::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad

      module RealtimeTranscriptionSessionAudioInputTurnDetection
        extend OpenAI::Internal::Type::Union

        type server_vad =
          {
            type: :server_vad,
            create_response: bool,
            idle_timeout_ms: Integer?,
            interrupt_response: bool,
            prefix_padding_ms: Integer,
            silence_duration_ms: Integer,
            threshold: Float
          }

        class ServerVad < OpenAI::Internal::Type::BaseModel
          attr_accessor type: :server_vad

          attr_reader create_response: bool?

          def create_response=: (bool) -> bool

          attr_accessor idle_timeout_ms: Integer?

          attr_reader interrupt_response: bool?

          def interrupt_response=: (bool) -> bool

          attr_reader prefix_padding_ms: Integer?

          def prefix_padding_ms=: (Integer) -> Integer

          attr_reader silence_duration_ms: Integer?

          def silence_duration_ms=: (Integer) -> Integer

          attr_reader threshold: Float?

          def threshold=: (Float) -> Float

          def initialize: (
            ?create_response: bool,
            ?idle_timeout_ms: Integer?,
            ?interrupt_response: bool,
            ?prefix_padding_ms: Integer,
            ?silence_duration_ms: Integer,
            ?threshold: Float,
            ?type: :server_vad
          ) -> void

          def to_hash: -> {
            type: :server_vad,
            create_response: bool,
            idle_timeout_ms: Integer?,
            interrupt_response: bool,
            prefix_padding_ms: Integer,
            silence_duration_ms: Integer,
            threshold: Float
          }
        end

        type semantic_vad =
          {
            type: :semantic_vad,
            create_response: bool,
            eagerness: OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness,
            interrupt_response: bool
          }

        class SemanticVad < OpenAI::Internal::Type::BaseModel
          attr_accessor type: :semantic_vad

          attr_reader create_response: bool?

          def create_response=: (bool) -> bool

          attr_reader eagerness: OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness?

          def eagerness=: (
            OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness
          ) -> OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness

          attr_reader interrupt_response: bool?

          def interrupt_response=: (bool) -> bool

          def initialize: (
            ?create_response: bool,
            ?eagerness: OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness,
            ?interrupt_response: bool,
            ?type: :semantic_vad
          ) -> void

          def to_hash: -> {
            type: :semantic_vad,
            create_response: bool,
            eagerness: OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness,
            interrupt_response: bool
          }

          type eagerness = :low | :medium | :high | :auto

          module Eagerness
            extend OpenAI::Internal::Type::Enum

            LOW: :low
            MEDIUM: :medium
            HIGH: :high
            AUTO: :auto

            def self?.values: -> ::Array[OpenAI::Models::Realtime::RealtimeTranscriptionSessionAudioInputTurnDetection::SemanticVad::eagerness]
          end
        end

        def self?.variants: -> ::Array[OpenAI::Models::Realtime::realtime_transcription_session_audio_input_turn_detection]
      end
    end
  end
end
